# 03 bubbleSort

## 정수를 요소로 갖는 배열을 입력받아 오름차순으로 정렬하여 리턴하기 <br/>
정렬 알고리즘 중 가장 기본적인 알고리즘 (롸?) <br/>
버블 정렬 알고리즘은 아래와 같습니다.

    1. 첫 번째 요소가 두 번째 요소보다 크면, 두 요소의 위치를 바꿉니다. (swap)
    2. 두 번째 요소와 세 번째 요소보다 크면, 두 요소의 위치를 바꿉니다. (swap)
    3. 1, 2를 마지막까지 반복합니다. (마지막에서 두 번째 요소와 마지막 요소를 비교)
    4. 1~3의 과정을 한 번 거치게 되면, 가장 큰 요소가 배열의 마지막으로 밀려납니다.
    5. 1~3의 과정을 첫 요소부터 다시 반복합니다.
    6. 5를 통해 두 번째로 큰 요소가 배열의 마지막 바로 두 번째로 밀려납니다.
    7. 1~3의 과정을 총 n번(배열의 크기) 반복합니다.
이 모습이 마치 '거품이 밀려 올라가는 것과 같은 모습'과 같아서 bubble sort라고 부릅니다. <br/> <br/>

```
[13,5,9,2,10]
[5,13,9,2,10]
[5,9,13,2,10]
[5,9,2,13,10]
[5,9,2,10,13]
```
이렇게 두개씩 비교해서 제일 큰 13이 맨 오른쪽으로 밀려났습니다  <br/><br/>

버블 정렬의 장점과 단점<br/>
장점<br/>
데이터 안에서 정렬을 하기에 메모리가 절약된다<br/>
단점 <br/>
자료의 개수가 많아지면 언제 다 비교함? 시간 복잡도를 가져버린다<br/><br/>

근데 전 시간 복잡도가 뭔지 몰라요<br/>
시간 복잡도<br/>
알고리즘을 처리하는데 걸리는 시간<br/>
Big-O 표기법으로 나타낸다<br/>
```
O(1) - Constant Time
데이터 크기와 상관없이 일정한 처리시간이 걸린다

O(n) - Linear Time
데이터가 커질수록 처리시간도 늘어난다

O(n²) - Quadratic Time
데이터의 크기의 제곱만큼 처리시간이 걸린다

O(log n)
한 번 처리할 때마다 데이터의 양이 절반씩 감소한다

등등...
```
아무튼 데이터를 두개씩 비교하면 오래걸리니까 효율적으로 코드를 작성하라는 뜻 같습니다 <br/><br/><br/>

## 풀이 1
```
const bubbleSort = function (arr) {
  // TODO: 여기에 코드를 작성합니다.
  for(let i=0; i<arr.length; i++){
    let change;
    for(let j=0; j<arr.length-1-i; j++){
      if(arr[j]>arr[j+1]){
        change = arr[j];
        arr[j] = arr[j+1];
        // arr[j+1] = arr[j];
        arr[j+1] = change;
      }
    }
    if(!change){
      break;
    }
  }
  return arr;
};

// 의사코드
// 이중반복문 작성
// 배열의 마지막 요소 (점점 줄어드는) 를 제외한 반복
// 잠깐 숫자를 저장해줄 변수 선언
// 조건문으로 배열의 첫번째 요소와 그 다음 요소를 비교합니다
// 첫번째 요소가 더 크다면 두번째 요소와 위치를 바꿔줍니다
// 더이상 바꿀 게 없다면 반복문을 멈춥니다
// arr 자체를 바꿔버리는 코드이므로 arr를 반환합니다
```

반복문으로 배열을 처음부터 끝까지 순회할거에요 <br/>
이중반복문으로 두개의 배열 요소를 비교할거에요 <br/>
여기서 j 를 arr.length - 1 - i 로 해준 이유가 무엇일까요 ? <br/>
정답은 바로 마지막 데이터(제일 큰 숫자)를 비교 대상에서 제외시켜줘야 하기 때문입니다 <br/>
(아마 시간복잡도 때문이겠지) <br/><br/><br/>

## 풀이 2
```
const bubbleSort = function (arr) {
  // TODO: 여기에 코드를 작성합니다.
  let stop;
  for(let i=arr.length; i>0; i--){
    let change;
    stop = true;
    for(let j=0; j<i-1; j++){
      if(arr[j] > arr[j+1]){
        change = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = change;
        stop = false;
      }
    }
    if(stop) break;
  }
  return arr;
};

// 의사코드
// 반복문으로 배열을 순회한다
// 이중반복문으로 데이터 2개를 비교한다
// 대신 이번엔 배열의 길이에서 하나씩 감소할 것 
// 변수를 2개 선언한다
// 하나는 반복문을 멈춰줄 변수
// 나머지 하나는 숫자를 임의로 저장해줄 변수
// 멈춰줄 변수가 true 일때 반복문을 멈춰준다우
```